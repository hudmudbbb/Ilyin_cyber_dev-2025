# Первый отчет
Видео: [Why Applications Are Operating-System Specific](https://youtu.be/eP_P4KOjwhs)

## Проблема OS-Специфичности Приложений
- Приложения являются **специфичными не только для архитектуры, но и для операционной системы (ОС)**.
- Исполняемый код, скомпилированный для одной ОС (например, Windows), не будет работать на другой (например, Mac или Linux), даже если обе работают на одной и той же архитектуре CPU (например, Intel x86).
- Основная причина этой несовместимости — зависимость программ от **системных вызовов**.

## Разделение Привилегий: Режимы Работы CPU
- Универсальные ОС должны безопасно совместно использовать аппаратные ресурсы, такие как CPU, между множеством процессов.
- Для предотвращения несанкционированного доступа к системе, CPU работает в двух основных режимах:
    - **Режим ядра (Kernel mode)**: Привилегированный режим, в котором CPU может выполнять *любую* инструкцию и имеет полный контроль над системой, включая управление устройствами ввода/вывода и аппаратными компонентами (таймеры, MMU).
    - **Пользовательский режим (User mode)**: Ограниченный режим, позволяющий выполнять только безопасный набор инструкций (перемещение данных, математические операции, циклы); CPU не может выполнять привилегированные инструкции для прямого управления оборудованием.
- Пользовательские программы работают в пользовательском режиме, а ОС — в режиме ядра.

## Системные Вызовы и Зависимость
- Поскольку пользовательские программы не могут напрямую манипулировать оборудованием, они должны запрашивать ОС о выполнении этих задач (например, чтение или запись файла).
- **Системные вызовы** (System Calls) предоставляют интерфейс к службам, предлагаемым операционной системой.
- Программы критически зависят от системных вызовов, постоянно запрашивая услуги ОС.
- Если другая ОС не реализует системные вызовы *точно* таким же образом (даже при наличии эквивалента), программа не будет работать.

> **ℹ️ Примечание:** Значение поля "voluntary context switches" (добровольные переключения контекста) в информации о процессе показывает, сколько раз процесс обращался к ОС через системные вызовы, и это число обычно очень велико.

## Различия в Реализации Системных Вызовов
- Функциональность эквивалентных системных вызовов может значительно различаться между ОС, даже если они выполняют одну и ту же общую задачу.

| Характеристика | Windows (`CreateProcess`) | Unix/Linux (`fork`) |
|:--- |:--- |:--- |
| **Основная функция** | Создает новый процесс, используя путь к исполняемому файлу. | Создает точную **копию (клон)** вызывающего процесса. |
| **Требуемые шаги** | Однократный системный вызов для создания процесса. | Требует дополнительного системного вызова, такого как **`exec`**, в дочернем процессе для замены его текстового раздела содержимым нового исполняемого файла. |
  

- На уровне машинного кода одинаковые задачи требуют разных инструкций на разных платформах, и эти дополнительные инструкции будут лишены смысла на другой ОС, что приведет к неопределенному поведению и сбоям.

## Механизм Вызова и ABI
- Когда программа запрашивает системную службу, она инициирует **прерывание (interrupt)**, заставляя CPU переключиться в режим ядра и передать управление ОС.
- На архитектурах x86-64 для этого используется специальная инструкция **`syscall`** (или `csol`).

### Идентификация и Передача Параметров
- **Идентификация:** Каждому системному вызову присваивается уникальный номер. Перед вызовом программа записывает соответствующий номер в регистр. ОС считывает это значение и обращается к **таблице системных вызовов (Syscall Table)**.
- **Проблемы с идентификацией:** Если две ОС используют разные таблицы системных вызовов или считывают номер вызова из разных регистров, одна и та же машинная инструкция может запросить совершенно разные службы, что приведет к поломке программы.
- **Передача параметров:** Многие системные вызовы требуют параметров, способ передачи которых зависит от ОС:
    - Некоторые системы требуют хранения параметров в регистрах.
    - Другие требуют записи параметров в определенную область памяти или комбинацию обоих методов.
    - *Пример (Linux):* Если системный вызов принимает менее шести параметров, они хранятся в регистрах; остальные записываются в память.
- Такие низкоуровневые детали, как метод хранения параметров в памяти (стек или определенное место) и ширина адреса для указателей, также должны совпадать.

  
   

---
## Интерфейс Двоичных Приложений (ABI) и Дополнительные Факторы
- Набор соглашений, определяющих, как различные компоненты двоичного кода взаимодействуют на конкретной ОС и архитектуре (включая регистры и передачу параметров), называется **Интерфейсом Двоичных Приложений (Application Binary Interface, ABI)**.

### Факторы несовместимости, не связанные с Syscalls
- **Формат Исполняемого Файла (Executable File Format):** Исполняемый файл содержит не только инструкции, но и данные, и **метаданные**, которые определяют, как ОС должна загружать и выполнять программу.
    - У каждой ОС есть специфические правила для этой структуры (например, **ELF** на Linux, **Portable Executable** на Windows).
- **Среды Выполнения (Runtime Environments):** Некоторые языки (например, JavaScript) не компилируются непосредственно в машинный код, а работают на виртуальной машине (ВМ) или интерпретаторе.
    - ВМ разработаны для обхода проблем совместимости, позволяя коду работать на разных платформах при условии, что ВМ установлена.
    - Однако, если современное приложение состоит из модулей, и хотя бы один модуль зависит от отсутствующей среды выполнения, все приложение может выйти из строя.


# Второй отчет 
Видео: [Signals: Make Ctrl+C Do Anything You Want](https://www.youtube.com/watch?v=m6WXrC9Mxzo)

## Сигналы как Межпроцессное Взаимодействие (МПВ)
*   Сигналы — это третий способ коммуникации между процессами, который не требует совместного использования памяти или интерфейса передачи сообщений.
*   Сигнал — это небольшое сообщение, которое уведомляет процесс о том, что в системе произошло какое-либо событие (подобно автомобильному гудку, сигнализирующему о том, что нужно двигаться).
*   Сигналы не предназначены для передачи больших объемов данных; они служат для уведомления процесса о наступлении события, чтобы тот мог немедленно запустить соответствующее действие.
*   Операционная система (ОС) определяет свой набор различных сигналов, которые могут отправляться процессам ядром или другими процессами.

## Отправка и Обработка Сигналов
*   Для отправки сигнала в C используется функция `kill(sig, pid)`, где `sig` — номер сигнала, а `pid` — ID процесса-получателя.
*   Получение сигнала позволяет ядру или другому процессу **прервать** выполнение процесса-получателя, даже если он находится в бесконечном цикле.
*   Каждый сигнал в процессе имеет **обработчик по умолчанию** (default handler).
*   Например, для сигнала **SIGUSR1** (одного из двух общих сигналов, которые программист может использовать по своему усмотрению), обработчик по умолчанию — **завершение процесса**.
*   Для определения того, как программа должна реагировать на сигнал, используется функция `signal(signum, handler)`.
*   `handler` — это указатель на функцию, которую ОС должна выполнить при получении указанного сигнала (`signum`).
*   Установка обработчика (формально — **установка обработчика для сигнала**) — это системный вызов, который сообщает ОС: "При получении этого сигнала немедленно приостанови то, что я делаю, и выполни эту функцию".
*   После выполнения обработчика программа возвращается к тому месту, где она была прервана.

## Механизм Ctrl+C и SIGINT
*   **Оболочка** (shell) — это программа, которая интерпретирует команды и действует как интерфейс между пользователем и ядром ОС, а **терминал** — это окно, отображающее ее вывод.
*   Некоторые комбинации клавиш, такие как **Ctrl+клавиша**, отправляют непечатаемые **управляющие символы** (control characters), которые изначально использовались для управления устройствами.
*   В Linux существует сигнал **SIGINT** (signal interrupt), означающий "прерывание с клавиатуры".
*   Когда пользователь нажимает **Ctrl+C** в терминале, драйвер терминала (часть ядра) интерпретирует это как запрос на отправку сигнала **SIGINT** группе процессов переднего плана.
*   Большинство программ завершаются при получении `SIGINT`, поскольку это их поведение по умолчанию, но его можно переопределить, написав собственный обработчик `SIGINT`.

## Принудительное Завершение и Неперехватываемые Сигналы
*   Для завершения фоновых процессов, которые могли установить собственные обработчики, существуют сигналы, которые **не могут быть перехвачены, заблокированы или проигнорированы** пользовательскими процессами.
*   Два таких сигнала: **SIGKILL** (номер 9) и **SIGSTOP** (номер 19).
*   При получении **SIGKILL** процесс **принудительно завершается** без выполнения каких-либо обработчиков или процедур очистки.
*   Утилита **`kill`** в Linux не только завершает процессы, но и позволяет вручную отправить **любой** сигнал любому процессу, используя функцию `kill()`.
*   Если команда `kill` вызывается без указания номера сигнала (например, `kill 1234`), по умолчанию отправляется **SIGTERM** (номер 15), который, в отличие от `SIGKILL`, может быть обработан.

## Приостановка, Возобновление и Группы Процессов
*   Сигналы, такие как **SIGSTOP**, заставляют процесс **остановиться** (заморозиться) без завершения его выполнения.
*   Процесс, остановленный таким образом, остается замороженным до тех пор, пока другой сигнал, обычно **SIGCONT** (signal continue), не скажет ему возобновить работу.
*   Нажатие **Ctrl+Z** в терминале отправляет процессу сигнал **SIGTSTP** (terminal stop), который по умолчанию останавливает процесс.
*   Сигналы можно отправлять не только отдельным процессам, но и целым **группам процессов**.
*   Если в функцию `kill` передается отрицательный ID процесса, сигнал отправляется всем процессам в группе, ID которой совпадает с абсолютным значением переданного ID.

## Системные События, Аппаратные Прерывания и Сигналы

| Событие Уровня Системы | Обнаруживается | Сигнал, Отправляемый Ядром | Поведение по Умолчанию |
|:--------------------- |:------------- |:------------------------- |:---------------------- |
| Попытка деления на ноль | CPU            | **SIGFPE** (Floating Point Exception) | Прерывание              |
| Попытка выполнения привилегированной инструкции | CPU | **SIGILL** (Illegal Instruction)      | Прерывание              |
| Попытка доступа к несанкционированной памяти | Аппаратное обеспечение CPU | **SIGSEGV** (Segmentation Violation) | Завершение и создание дампа ядра |
   

*   Когда происходит системное событие (например, деление на ноль), внутренняя схема CPU обнаруживает его и вызывает аппаратное прерывание, на которое ядро реагирует отправкой соответствующего сигнала процессу.
*   Сообщение "Segmentation fault core dumped" (Ошибка сегментации, дамп ядра) появляется, потому что обработчик по умолчанию для **SIGSEGV** завершает процесс и создает дамп ядра.
*   > **⚠️ Осторожно:** Хотя технически для `SIGSEGV` можно установить пользовательский обработчик, это считается плохой идеей, поскольку может привести к усугублению проблем.

## Заключение
*   Сигналы обычно не преподаются как стандартная форма МПВ, поскольку они передают события системного или пользовательского уровня, а не данные общего назначения; поэтому они чаще классифицируются как **исключительный поток управления**.
*   Неправильная обработка сигналов может вызвать **состояния гонки** (race conditions) даже в однопоточных программах, поэтому при работе с ними требуется особая осторожность.


# Третий отчет 
Видео: [ARRAYLIST VS LINKEDLIST](https://www.youtube.com/watch?v=xFMXIgvlgcY)

## Основы Массивов в Системном Программировании
- Массивы содержат элементы, занимающие последовательные (смежные) позиции в памяти, что позволяет использовать индекс для доступа.
- При объявлении массива в системных языках (например, C) необходимо указать тип элементов и длину, что определяет требуемое место в памяти.
- Компилятор использует информацию о типе, чтобы узнать, сколько байтов занимает каждый элемент, и вычисляет общий объем памяти путем умножения размера элемента на длину массива.
- Доступ к элементу по индексу осуществляется с использованием базового адреса массива и формулы: адрес = Базовый Адрес + (Размер Элемента * Индекс).
- Индексация начинается с нуля, поскольку для доступа к первому элементу (индекс 0) смещение указателя не требуется.
- **Проблема фиксированного размера:** Массивы не могут динамически расширяться, так как добавление элементов может перезаписать другие значения в памяти, что приводит к критическим ошибкам.
- На низком уровне массив — это просто блок памяти, не содержащий информации о своем размере (**длине**), что делает проверку границ индекса невозможной.
- Попытка доступа за пределы массива может привести либо к ошибке **Segmentation Fault** (если ОС обнаруживает доступ за пределы выделенной памяти процесса), либо к продолжению выполнения с неверными данными (если доступ осуществляется внутри границ процесса).

---

## Динамические Списки: ArrayList и LinkedList

### ArrayList (Вектор)
- **ArrayList** использует массив внутри, но добавляет атрибуты `capacity` (емкость) и `length` (текущее количество элементов) для управления размером.
- **Добавление элементов (`push`):** Перед добавлением проверяется, равен ли `length` значению `capacity`.
- Если массив полон, происходит **динамическое изменение размера**: выделяется новый, более крупный массив (обычно вдвое больше), элементы копируются, старый массив освобождается, и только затем добавляется новый элемент.
- **Производительность изменения размера:** Этот процесс включает выделение памяти в куче и копирование элементов, что может негативно сказаться на производительности.
- **Оптимизация:** Если приблизительный размер известен, рекомендуется создавать `ArrayList` с начальной емкостью, чтобы уменьшить частоту операций изменения размера.

Вот блок-схема процесса добавления элемента в `ArrayList` при достижении максимальной емкости:
  
   

### LinkedList (Связный Список)
- **Реализация:** Элементы хранятся в узлах (`node`), которые разбросаны по памяти. Каждый узел содержит сам элемент (`item`) и указатель (`pointer`) на следующий узел.
- **Динамический размер:** Легко увеличивается, так как новый узел размещается в любом доступном месте памяти, и указатель последнего узла обновляется.
- **Проблема Кэширования:** Из-за того, что узлы разбросаны, они крайне редко попадают в кэш процессора, что приводит к частым **промахам кэша** (cache misses) и значительно замедляет обработку данных.

---

## Сравнение Производительности и Доступа

| Операция | ArrayList | LinkedList | Примечания |
|:--- |:--- |:--- |:--- |
| **Доступ по Индексу** | $$O(1)$$ (Константное время) | $$O(N)$$ (Линейное время) | `ArrayList` использует формулу адресации; `LinkedList` требует обхода с головы     |
| **Удаление Элемента** | $$O(N)$$ (Линейное время) | $$O(1)$$ *после* нахождения элемента | `ArrayList` требует сдвига элементов; `LinkedList` требует только обновления указателей, но поиск занимает $$O(N)$$      |
| **Эффективность Кэша** | Высокая | Низкая | `ArrayList` хранит элементы компактно; `LinkedList` элементы разбросаны     |
      

> **ℹ️ Note:** Хотя удаление в `LinkedList` технически является операцией $$O(1)$$, общая неэффективность доступа к элементам (из-за $$O(N)$$ поиска и плохого кэширования) часто делает его медленнее на практике. Выбор структуры данных зависит от конкретных архитектур и требует бенчмаркинга.

---

## Реализация в Языках Высокого Уровня

### Обработка Типов (Generics)
- **Системные языки (например, Rust):** Компилятор генерирует исходный код, специфичный для конкретного типа, подставляя его вместо обобщенного (generic) типа, обеспечивая ожидаемую структуру данных в памяти.
- **Java (Непримитивные типы):** Виртуальная машина (VM) создает массив **указателей**, которые указывают на адреса в памяти, где хранятся сами элементы. Язык скрывает эти указатели от программиста.
- Если в Java используется `LinkedList`, узлы содержат указатель на элемент *и* указатель на следующий узел, что еще больше усугубляет проблему кэширования.

### Скриптовые Языки (Python и JavaScript)
- Скриптовые языки (Python, JavaScript) обычно не компилируются в машинный код, а полагаются на **интерпретаторы** или виртуальные машины для эмуляции поведения.

- **Python Lists:** Реализованы как массив указателей на объекты (`py list object`), что похоже на подход Java для непримитивных типов.
- **Ключевое отличие Python:** Эти указатели могут указывать на объекты **разных типов**, что позволяет спискам Python быть гетерогенными (содержать элементы разных типов).
- Интерпретатор Python симулирует индексацию, сначала индексируя массив указателей, а затем считывая значение, на которое указывает указатель.

- **JavaScript Arrays:** На самом деле являются **хэш-картами (hashmaps)**.
- Когда массив JS объявляется, движок создает хэш-карту, где **ключи** соответствуют числовым индексам.
- Индексация в JavaScript — это синтаксический сахар для получения элемента из хэш-карты по его ключу.
- **Преимущество JS Hashmap:** Добавление элемента по очень большому индексу (например, 1 миллион) не требует выделения памяти для всех промежуточных пустых позиций; память выделяется только для самого нового элемента.
