## Проблема OS-Специфичности Приложений
- Приложения являются **специфичными не только для архитектуры, но и для операционной системы (ОС)**.
- Исполняемый код, скомпилированный для одной ОС (например, Windows), не будет работать на другой (например, Mac или Linux), даже если обе работают на одной и той же архитектуре CPU (например, Intel x86).
- Основная причина этой несовместимости — зависимость программ от **системных вызовов**.

## Разделение Привилегий: Режимы Работы CPU
- Универсальные ОС должны безопасно совместно использовать аппаратные ресурсы, такие как CPU, между множеством процессов.
- Для предотвращения несанкционированного доступа к системе, CPU работает в двух основных режимах:
    - **Режим ядра (Kernel mode)**: Привилегированный режим, в котором CPU может выполнять *любую* инструкцию и имеет полный контроль над системой, включая управление устройствами ввода/вывода и аппаратными компонентами (таймеры, MMU).
    - **Пользовательский режим (User mode)**: Ограниченный режим, позволяющий выполнять только безопасный набор инструкций (перемещение данных, математические операции, циклы); CPU не может выполнять привилегированные инструкции для прямого управления оборудованием.
- Пользовательские программы работают в пользовательском режиме, а ОС — в режиме ядра.

## Системные Вызовы и Зависимость
- Поскольку пользовательские программы не могут напрямую манипулировать оборудованием, они должны запрашивать ОС о выполнении этих задач (например, чтение или запись файла).
- **Системные вызовы** (System Calls) предоставляют интерфейс к службам, предлагаемым операционной системой.
- Программы критически зависят от системных вызовов, постоянно запрашивая услуги ОС.
- Если другая ОС не реализует системные вызовы *точно* таким же образом (даже при наличии эквивалента), программа не будет работать.

> **ℹ️ Примечание:** Значение поля "voluntary context switches" (добровольные переключения контекста) в информации о процессе показывает, сколько раз процесс обращался к ОС через системные вызовы, и это число обычно очень велико.

## Различия в Реализации Системных Вызовов
- Функциональность эквивалентных системных вызовов может значительно различаться между ОС, даже если они выполняют одну и ту же общую задачу.

| Характеристика | Windows (`CreateProcess`) | Unix/Linux (`fork`) |
|:--- |:--- |:--- |
| **Основная функция** | Создает новый процесс, используя путь к исполняемому файлу. | Создает точную **копию (клон)** вызывающего процесса. |
| **Требуемые шаги** | Однократный системный вызов для создания процесса. | Требует дополнительного системного вызова, такого как **`exec`**, в дочернем процессе для замены его текстового раздела содержимым нового исполняемого файла. |
  

- На уровне машинного кода одинаковые задачи требуют разных инструкций на разных платформах, и эти дополнительные инструкции будут лишены смысла на другой ОС, что приведет к неопределенному поведению и сбоям.

## Механизм Вызова и ABI
- Когда программа запрашивает системную службу, она инициирует **прерывание (interrupt)**, заставляя CPU переключиться в режим ядра и передать управление ОС.
- На архитектурах x86-64 для этого используется специальная инструкция **`syscall`** (или `csol`).

### Идентификация и Передача Параметров
- **Идентификация:** Каждому системному вызову присваивается уникальный номер. Перед вызовом программа записывает соответствующий номер в регистр. ОС считывает это значение и обращается к **таблице системных вызовов (Syscall Table)**.
- **Проблемы с идентификацией:** Если две ОС используют разные таблицы системных вызовов или считывают номер вызова из разных регистров, одна и та же машинная инструкция может запросить совершенно разные службы, что приведет к поломке программы.
- **Передача параметров:** Многие системные вызовы требуют параметров, способ передачи которых зависит от ОС:
    - Некоторые системы требуют хранения параметров в регистрах.
    - Другие требуют записи параметров в определенную область памяти или комбинацию обоих методов.
    - *Пример (Linux):* Если системный вызов принимает менее шести параметров, они хранятся в регистрах; остальные записываются в память.
- Такие низкоуровневые детали, как метод хранения параметров в памяти (стек или определенное место) и ширина адреса для указателей, также должны совпадать.

  
   

---
## Интерфейс Двоичных Приложений (ABI) и Дополнительные Факторы
- Набор соглашений, определяющих, как различные компоненты двоичного кода взаимодействуют на конкретной ОС и архитектуре (включая регистры и передачу параметров), называется **Интерфейсом Двоичных Приложений (Application Binary Interface, ABI)**.

### Факторы несовместимости, не связанные с Syscalls
- **Формат Исполняемого Файла (Executable File Format):** Исполняемый файл содержит не только инструкции, но и данные, и **метаданные**, которые определяют, как ОС должна загружать и выполнять программу.
    - У каждой ОС есть специфические правила для этой структуры (например, **ELF** на Linux, **Portable Executable** на Windows).
- **Среды Выполнения (Runtime Environments):** Некоторые языки (например, JavaScript) не компилируются непосредственно в машинный код, а работают на виртуальной машине (ВМ) или интерпретаторе.
    - ВМ разработаны для обхода проблем совместимости, позволяя коду работать на разных платформах при условии, что ВМ установлена.
    - Однако, если современное приложение состоит из модулей, и хотя бы один модуль зависит от отсутствующей среды выполнения, все приложение может выйти из строя.
